###多线程
* 1.线程是程序执行的一条路径,一个进程可以包含多条线程
* 2.多线程可以提高程序执行的效率,可以同时完成多项工作

###多线程(并行和并发的区别)
* 并行是指两个任务同时运行(需要多接cpu)
* 并发就是指两个任务同时请求运行,二处理器只能接受一个任务,就把两个任务安排轮流进行,由于时间间隔较短,感觉两个任务都在同时运行(同时出发 一会这个一会那个)

###Java的运行原理和JVM的运行时多线程的
	* jvm至少调用了 主方法和垃圾回收进程
###创建新线程的方法
	* 一.继承成为Thread的子类 并重写run方法 将想要执行的代码写在run方法中 创建Thread的子类对象  开启线程  对象.start();
	* 二.实现Runnable接口 并重写run方法  创建子类对象 将接口子类对象作为参数传到Thread的构造方法中 然后 调用strat方法

###两种方法的区别
* 查看源码的区别:
	* a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法
	* b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法
	
* 继承Thread
	* 好处是:可以直接使用Thread类中的方法,代码简单
	* 弊端是:如果已经有了父类,就不能用这种方法
* 实现Runnable接口
	* 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的
	* 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂

* 匿名内部类实现线程的方法
	* 一.new Thread() {
			public void run() {
				
			}
		}.start();
	  二.new Thread(new Runnable() {
			public void run() {
				
			}
		}).start();
###获取设置线程名字
* 1.获取名字
	* 通过getName()方法获取线程对象的名字
* 2.设置名字* Thread.currentThread()
	* 通过构造函数可以传入String类型的名字
	* 通过setName(String)方法可以设置线程对象的名字

###获取当前线程的对象
* Thread.currentThread()

###休眠线程
* Thread.sleep(毫秒，纳秒（不需要）);
* 需要抛出InterruptedException 或者捕捉
* 在匿名内部类中 需要用捕捉异常 因为父类Thread没有抛出这个异常 子类不能比父类更差

###守护线程
* setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出
* 但是不会立即关闭 有一点延迟

###加入线程
*  join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续
* join(int), 可以等待指定的毫秒之后继续 就是指定可以插队多久
* 匿名内部类里面调用时 调用对象必须用 final修饰 

###礼让线程
* yield让出cpu(效果不明显 了解)

###24.15_多线程(设置线程的优先级)(了解)
* setPriority(int i)设置线程的优先级  范围1-10  默认优先级是5
* 优先级不是绝对的 是概率大一点
* Thread.MAX_PRIORITY  Thread.MIN_PRIORITY

###同步代码块
* 1.什么情况下需要同步
	* 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.
	* 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.
* 2.同步代码块
	* 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块
	* 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的
* 3.锁对象可以是任意对象 但是不能用匿名对象 因为匿名对象不是同一个对象
*  synchronized（d） {}

###同步方法
* 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的
	* 非静态同步函数的锁是:this
	* 静态的同步函数的锁是:字节码对象---类名.class

###线程安全问题
* 多线程并发操作同一数据时, 就有可能出现线程安全问题
* 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作
* 需要用同步代码块 锁可以用该类的字节码文件 或者 自定义对象 但是必须用是静态
* 多次启动一个线程是非法的

###死锁
* 嵌套导致死锁 为了避免  所以同步代码块不要嵌套

###线程安全的类的回顾
* 线程安全 Vector StringBuffer HashTable 
* 线程不安全 ArrayList StringBuilder HashMap
* Collections.synchronizedXXX(XXX) 可以吧不安全的转化成安全的