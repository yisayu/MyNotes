###day6 
* 面向对象思想
	* 一种东西 = 类
	* 属性大小 形状 = 成员变量 
	* 功能 作用 = 成员方法 具体实施步骤被封装在成员方法里面
	* 对象就是这种东西某一个具体的实物
* 面向对象特点封装 继承 多态(父类应用 指向子类对象)(重写返回值可以是子父类关系)
 
* 匿名对象: new car().run()用来调用方法 只调用一次使用
* 封装:隐藏对象的属性和实现细节,只对外提供公共的访问方式 有复用性 安全性
* this.变量 区分成员变量和局部变量重名;

###day7
* 构造方法重载:不能有返回值 只改变参数 自己写了有参构造 一般给出无参构造
* 创造对象内存图步骤
	* Student s = new Student();
	* 1,Student.class加载进内存
	* 2,声明一个Student类型引用s
	* 3,在堆内存创建对象,
	* 4,给对象中属性默认初始化值
	* 5,属性进行显示初始化
	* 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈
	* 7,将对象的地址值赋值给s (复习时自己画内存图)
* static依附于类 随着类的存在而存在 可以通过类名直接调用(静态存在于内存方法区的静态区)
	* 静态变量 一次赋值全家使用
	* 静态方法 可以通过类名直接调用
	* 静态 只能访问静态 不能访问任何不静态的东西
* 主函数
	* public 权限大 jvm能调用
	* static 静态 jvm调用不用创对象
	* void jvm不需要返回值
	* main 能被jvm识别
	* String[] args 以前用于键盘录入 
* Math.random() 0.0 < x < 1.0是double 1-100随机数 (int)Math.random()*100 + 1;

###day8
* 代码块
	* {}每个构造函数调用都运行一次
	* static{} 类加载的时候运行一次
	* 局部代码块放在方法里 没什么卵用 主要是减少他的寿命 提高内存利用率
* 继承好处 复用性 维护性 多态前提
* 弊端 耦合性 一改全改 
* 开发最好高内聚 独立完成  低耦合 类与类之间的关系
* 构造函数
   子类不会继承父类的构造函数 但是每个子类的构造函数都会用super()访问父类构造函数
   * super() this()都必须在构造方法的第一句
* 子类重写父类的方法第一排方法声明必须和父类一样(返回值可以是子父类关系)  重载都可以改 名字一样就行了 (重载必须在同一个类中)
* final 修饰类 断子绝孙 不能继承  修饰方法 不能洗心革面被重写 (可以重载) 修饰变量变成常量 只能一次赋值
* final 修饰的赋值时机  定义时赋值 构造函数里赋值

###day9
* 多态 要求 1继承 2重写(不重写 怎么体现多态的效果) 3父类引用指向子类对象
* 多态是只有访问非静态方法事编译看父类 运行看子类 也就是非静态结果是子类的运行结果 其他都是父类
* 向上转型 Person p = new SuperMan() 向下转型 SuperMan sm = (SuperMan)p
* 多态好处 维护性 扩展性 把父类当做形参 子类的对象都可以放进去 
* 弊端 不能使用子类特有的类型和方法
* 抽象类与普通类的区别可以!!!是可以不是必须放抽象方法 且不能实例化 只能通过子类多态实例化
* 抽象类 子类 要么抽象类继承父类 要么就重写父类所有的抽象方法
* abstract 不能修饰成员变量  没有抽象的方法的抽象类就是为了自己不创建对象 让子类完成
* 接口成员特点 成员变量必须是常量 public static final 自动给出 最好自己给
				没有构造函数  成员方法必须是抽象的
*类与接口关系 
	类与类单继承 多层继承
	接口与类 可多实现
	接口与接口  可多继承
* 设计理念: 抽象类是抽取共性的 子类是父类的一种 接口是特性 举例 jumpcat

###day10
* 包名 域名倒过来+功能
* 建包 必须是第一句代码 一个java文件只能有一个 
* 手动运行包 javac -d .HelloWorld.java
			java 包名.HelloWorld
* 导入包 import 不导入包 不导入包 创建对象时要写全类名
		* 	权限区别    本类	 同一个包下(子类和无关类)	不同包下(子类)	不同包下(无关类)
			private 	Y		
	   默认(friendly)	Y		Y 
			protected	Y		Y							Y
			public		Y		Y							Y				Y
* 内部类 可以直接访问外部类的成员 外部类要创建对象才能访问内部类
* 创建对象方法 外部类名.内部类名 对象名 = 外部类对象.内部类对象;
* private修饰内部类 通过外部类中写创建内部类对象的方法
* 静态内部类 创建对象 外部类名.内部类名 对象名 = 外部类名.内部类对象;
* 局部`内部类访问局部变量时要用final修饰 与方法弹栈变量消失有关 其实应该是个bug jdk1.8	取消了
* (重点) 匿名内部类 是局部内部类的一种 要放在方法中  他的作用就是用来实现一个接口或者一个抽象类的 然后创建其子对象的 但是只能使用一次 多次使用 就用内部类
* 格式 new 类名或接口名(){
				}